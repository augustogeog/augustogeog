{
  
    
        "post0": {
            "title": "Entendendo o Plotly Figure Object",
            "content": "A import&#226;ncia dos Objetos nos Pacotes do Ecossistema PythonData . Em Python, a programação orientada a objeto é a tônica. Assim, os diversos pacotes do ecossistema de tecnologias para dados apresentam objetos a partir dos quais orbitam todas as suas funcionalidades. No pacote Numpy o principal objeto é o Array. enquanto Pandas* tem o DataFrame, por sua vez Pytorch conta com o Tensor e Scikit-Learn** traz os seus estimadores. Por isso, dominar essas ferramentas significa conhecer bem esses tipos de objetos, com sua estrutura, métodos, atributos e lógicas para otimização de uso. . No caso do pacote Plotly, voltado para produção de gráficos, não é diferente. Por essa razão, adiante vou apresentar uma breve discussão sobre o que é o Plotly Figure Object e como ele funciona, para que possamos ser mais efetivos na elaboração dos mais diversos produtos analíticos - gráficos, mapas e diagramas. . Como Plotly Renderiza Gr&#225;ficos? . Para podermos tratar do que é um Plotly Figure Object, é importante entendermos primeiramente como a biblioteca renderiza seus belos produtos gráficos. Nesse sentido, precisamos reconhecer que a versao Plotly em linguagem Python gera instruções para produção de gráficos, mas não é ela que os renderiza. Por se tratarem de gráficos interativos, os desenvolvedores optaram por fazer esse tipo de renderização em JavaScript, linguagem mais popular para desenvolvimento web. . Para poder gerar orientações em Python que pudessem servir para renderização de gráficos em Plotly JavaScript, a Python Plotly deve gerar informações em formato JSON - JavaScript Object Notation -, uma notação bastante popular no desenvolvimento web por conta de sua capacidade de otimização de transferência de dados em formatos de árvores. . Vejamos como essa ideia de árvores ajuda a motarmos um gráfico com elevado nível de abstração, ou seja, sem entrar em diversos detalhes que precisam ser considerados pelo renderizador. . Dados . x [-5,-4,-3,-2,-1,0,1,2,3,4,5] | . | y [25, 16, 9, 4, 1, 0, 1, 4, 9, 16, 25] | . | orientação &#39;vertical&#39; | . | tipo &#39;pontos dispersos&#39; | . | modo &#39;linhas&#39; | . | linha cor azul | . | traço sólido | . | . | Layout . altura 300 pixels | . | largura 1000 pixels | . | . | . Por essa lógica de passarmos um conjunto de instruções em árvore para renderização de um gráfico, poderíamos pensar em algo assim como no exemplo acima. Poderíamos ter duas principais raízes, dados e layout. Em dados nós fazemos o mapeamento dos dados numéricos a suas respectivas representações pictóricas. Assim, os valores de -5 a 5 podem ser associados ao eixo x, enquanto os seus quadrados podem ser associados ao eixo y, mantendo uma representação vertical, em que o eixo x é o horizonta e o y, vertical. Esses valores podem ser representados por pontos dispersos - scatter -, ligados por linhas. A linha pode ter cor azul e o traço sólido. . Além da representação dos próprios dados e suas especificações, também poderíamos gerar comandos para a o layout de maneira geral, naquilo que independende dos dados (altura do gráfico, largura, margens, cor de fundo, marcadores nos eixos e suas fontes etc. No nosso exemplo, o Layout conta com altura de 300 pixels e largura de 1000 pixels. . Bastante simples, não? Agora vejamos como o Plotly gera um gráfico como esses e como ele configura esse conjunto de instruções: . import plotly.express as px import numpy as np nums = np.array(range(-5,6)) quadrados = nums ** 2 fig = px.line(x=nums, y=quadrados, height=300, width=1000) fig.show() . . . Acima, o processo é bastante simples, importammos Express, a API de alto nível de abstração do Plotly, criamos um array de números inteiros entre -5 e 5, nums, e calculamos seus quadrados. Em seguida, com a função line, para fazer um gráfico de linha, associamos os números ao x, os quadrados ao y, e especificamos a altura e a largura do gráfico em pixels. Por fim, usamos o método show na figura que geramos e que foi atribuída à variável fig. Voilà! . O Plotly Figure Object . Já vimos anteriormente que Plotly Python usa essas funções para gerar instruções em JSON para que sejam passadas a Plotly JavaScript, que renderiza os gráficos. Assim, vejamos agora como são essas instruções. . print(fig) . Figure({ &#39;data&#39;: [{&#39;hovertemplate&#39;: &#39;x=%{x}&lt;br&gt;y=%{y}&lt;extra&gt;&lt;/extra&gt;&#39;, &#39;legendgroup&#39;: &#39;&#39;, &#39;line&#39;: {&#39;color&#39;: &#39;#636efa&#39;, &#39;dash&#39;: &#39;solid&#39;}, &#39;mode&#39;: &#39;lines&#39;, &#39;name&#39;: &#39;&#39;, &#39;orientation&#39;: &#39;v&#39;, &#39;showlegend&#39;: False, &#39;type&#39;: &#39;scatter&#39;, &#39;x&#39;: array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]), &#39;xaxis&#39;: &#39;x&#39;, &#39;y&#39;: array([25, 16, 9, 4, 1, 0, 1, 4, 9, 16, 25]), &#39;yaxis&#39;: &#39;y&#39;}], &#39;layout&#39;: {&#39;height&#39;: 300, &#39;legend&#39;: {&#39;tracegroupgap&#39;: 0}, &#39;margin&#39;: {&#39;t&#39;: 60}, &#39;template&#39;: &#39;...&#39;, &#39;width&#39;: 1000, &#39;xaxis&#39;: {&#39;anchor&#39;: &#39;y&#39;, &#39;domain&#39;: [0.0, 1.0], &#39;title&#39;: {&#39;text&#39;: &#39;x&#39;}}, &#39;yaxis&#39;: {&#39;anchor&#39;: &#39;x&#39;, &#39;domain&#39;: [0.0, 1.0], &#39;title&#39;: {&#39;text&#39;: &#39;y&#39;}}} }) . Isso acima, meus caros, é o Plotly Figure Object, ou seja, é esse conjunto de elementos e atributos em forma de árvore (um mero dicionário em Python, ou JSON em JavaScript) que instruem a renderização dos gráficos. Vemos que a raiz é constituída pelo por data e layout, como apresentado no exemplo com tópicos. Observe que os galhos são chaves, que indicam elementos sobre os quais se quer especificar um determinado atributo, com valores designados nas folhas, ou, nos mais externos valores desse grande objeto que mais parece um dicionário Python. . . Plotly Figure Objects também contam com uma terceira raiz, Frames. Ela é opcional, no entanto e só aparece na estrutura quando especificamos que nossos gráficos devem ser animados, como as corridas de barras que se tornaram populares no Youtube . De fato, a estrutura é um pouco mais complexa do que o nosso exemplo anterior. Em parte, compreender os principais caminhos dessa árvore corresponde justamente àquilo que precisamos para elaborar figuras com maior nível de personalização. . Então, voltemos duas casas para entender essa estrutura. Para tanto vamos elaborar um gráfico sem qualquer dado e ver do que se trata . fig2 = px.line() fig2 . . . print(fig2) . Figure({ &#39;data&#39;: [], &#39;layout&#39;: {&#39;legend&#39;: {&#39;tracegroupgap&#39;: 0}, &#39;margin&#39;: {&#39;t&#39;: 60}, &#39;template&#39;: &#39;...&#39;, &#39;xaxis&#39;: {&#39;anchor&#39;: &#39;y&#39;, &#39;domain&#39;: [0.0, 1.0]}, &#39;yaxis&#39;: {&#39;anchor&#39;: &#39;x&#39;, &#39;domain&#39;: [0.0, 1.0]}} }) . Notamos acima que temos algo muito mais simples. Trata-se de um gráfico vazio cujo Figure Object não apresenta qualquer valor associado à raiz data. Em layout poucas especificações são dadas. O eixo x é ancorado no eixo y, o eixo y é ancorado no eixo x e ambos tomam 100% da área plotada, de 0 a 1. Há uma margem no topo, de 60 pixels (se fosse na parte inferior seria b, na esquerda seria l, na direita seria especificado o elemento t). O intervalo entre grupos na legenda é de zero, mas aqui também não muda nada, afinal não há legenda! . O importante é notar que temos um elemento/chave/galho chamado template, cujo atributo/valor/folha está destacado por reticências, indicando que é um texto muito grande para ser mostrado. É nesse lugar que encontramos diversos elementos e atributos que não escolhemos, mas que estão renderizados na figura acima (cor cinza do fundo, posição dos marcadores dos eixos, fonte dos marcadores e cor das linhas de grade). Assim, o template contém os padrões que devem ser utilizados para aqueles elementos que não forem explicitamente indicados por nós nas funções de geração de Figure Objects. . Agora que vimos um objeto sem dados, fica um pouco mais fácil entender o que acontece no objeto anterior. Abaixo vamos ver cada um dos elementos da raiz data da primeira figura, com seus atributos: . {&#39;hovertemplate&#39;: &#39;Números de -5 a 5=%{x} Quadrados=%{y} &#39;, formato da caixa que aparece ao apontar o cursor sobre um ponto no gráfico &#39;legendgroup&#39;: &#39;&#39;, Nenhum grupo de legenda indicado &#39;line&#39;: {&#39;color&#39;: &#39;#636efa&#39;, &#39;dash&#39;: &#39;solid&#39;}, linha de cor azul e com traço sólido &#39;mode&#39;: &#39;lines&#39;, gráfico em modo linha &#39;name&#39;: &#39;&#39;, **gráfico sem título** &#39;orientation&#39;: &#39;v&#39;, orientação vertical &#39;showlegend&#39;: False, legenda desativada &#39;type&#39;: &#39;scatter&#39;, gráfico de tipo pontos esparsos, ou scatter plot &#39;x&#39;: array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]), dados associados ao eixo x &#39;xaxis&#39;: &#39;x&#39;,nome do eixo x &#39;y&#39;: array([25, 16, 9, 4, 1, 0, 1, 4, 9, 16, 25]), dados associados ao eixo y &#39;yaxis&#39;: &#39;y&#39;} nome do eixo y . . É comum que a mesma coisa tenha diferentes nomes em diferentes contexto. Quando pensamos em estrutura de árvore, um determinado nó pode ser um galho. Quando pensamos em dicionários, o nome adequado é chave. Como estamos falando justamente da interface entre JavaScript, Python e plotagem de gráficos, por vezes esses termos são utilizados de maneira intercambiável . Embrulha para Viagem . Vimos que Python Plotly gera especificações em forma de árvore para renderização em Plotly JS. Observamos que essas especificações são realizadas em formato JSON. Assim, notamos que as funções para geração de gráficos em Plotly, na realidade, criam Plotly Figure Objects, que são esses comandos a serem serializados em JSON. Esses objetos contêm especificações sobre data (elementos e atributos referentes ao mapeamento dos dados a elementos gráficos), layout (características gerais das figuras, como sua altura, largura, marcadores de eixos, linhas de grade, cor de fundo etc.) e Frames (raiz opcional que apresenta caracteristicas referentes a animações). Elementos não são especificados no Layout contam com atributos padrão, no nó template. . Plotly conta com centenas e centenas de elementos e atributos que nos permitem fazer a customização dos nossos gráficos. Por essa razão, saber essa estrutura do Figure Object é fundamental, pois as diversas formas que temos para alterar a esses elementos correspondem a mudanças nessa estrutura de árvore. Muitas vezes, por serem tantas as possibilidades, encontrar esses elementos na árvore pode fazer toda a diferença para que possamos .",
            "url": "https://augustogeog.github.io/augustogeog/plotly/gr%C3%A1ficos/python/2021/06/04/figura-plotly.html",
            "relUrl": "/plotly/gr%C3%A1ficos/python/2021/06/04/figura-plotly.html",
            "date": " • Jun 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Conhecendo a Estrutura do Plotly (Parte 2)",
            "content": "Dando Continuidade . Há alguns dias, publiquei uma postagem em que defendi que, em meio a tantas ferramentas disponíveis no ecossistema Python para dados, é importante que os profissionais nas carreiras intensivas em tecnologias de dados escolham aqueles pacotes que pretendem dominar, conhecendo a fundo sua lógica de funcionamento, principais ferramentas e estrutura. Por isso, apresentei três dos sete subpacotes do Plotly, aquele que escolhi como meu principal instrumento para elaboração de produtos analíticos diversos - gráficos, cartogramas e diagramas -, por conta de sua versatilidade, rápida curva de aprendizado e seus resultados belos e interativos. . Na primeira postagem tratei dos supacotes Plotly Data (carregamento de datasets-exemplos como Pandas DataFrame), Plotly Express (interface de alto nível de abstração que permite fazer gráficos arrojados com uma única função) e Plotly Colors (funções que geram diferentes tipos de paletas de cores cíclicas, divergentes, sequenciais e qualitativas. Adiante, busco apresentar os outros quatro subpacotes principais: Graph Objects, Subplots, I/O e Figure Factories. . Graph Objects . O subpacote Graph Objects é aquele que contém as classes e funções para a elaboração dos produtos analíticos. Mas isso não tem no Plotly Express, Augusto? Sim! No entanto, o Express é uma interface mais simplificada que justamente usa os Graph Objects para gerar os gráficos. Com isso, ganha-se em intuitividade da programação, mas perde-se em capacidade de customização. Nesse sentido, se quisermos fazer um gráfico, mapa ou diagrama mais customizado devemos descer mais no nível de abstração e utilizar Graph Objects. Por vezes, também podemos iniciar um gráfico na API mais alta e utilizar as ferramentas disponíveis nos mais baixos níveis para procedimentos de personalização. . Como estamos descendo mais no nível de abstraçao, podemos entendermo melhor o que é um gráfico Plotly. . import plotly.express as px import numpy as np nums = np.array(range(-5,6)) quadrados = nums**2 fig = px.line(x=nums, y=quadrados, height=300) fig.show() . print(fig) . Figure({ &#39;data&#39;: [{&#39;hovertemplate&#39;: &#39;x=%{x}&lt;br&gt;y=%{y}&lt;extra&gt;&lt;/extra&gt;&#39;, &#39;legendgroup&#39;: &#39;&#39;, &#39;line&#39;: {&#39;color&#39;: &#39;#636efa&#39;, &#39;dash&#39;: &#39;solid&#39;}, &#39;mode&#39;: &#39;lines&#39;, &#39;name&#39;: &#39;&#39;, &#39;orientation&#39;: &#39;v&#39;, &#39;showlegend&#39;: False, &#39;type&#39;: &#39;scatter&#39;, &#39;x&#39;: array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]), &#39;xaxis&#39;: &#39;x&#39;, &#39;y&#39;: array([25, 16, 9, 4, 1, 0, 1, 4, 9, 16, 25]), &#39;yaxis&#39;: &#39;y&#39;}], &#39;layout&#39;: {&#39;height&#39;: 300, &#39;legend&#39;: {&#39;tracegroupgap&#39;: 0}, &#39;margin&#39;: {&#39;t&#39;: 60}, &#39;template&#39;: &#39;...&#39;, &#39;xaxis&#39;: {&#39;anchor&#39;: &#39;y&#39;, &#39;domain&#39;: [0.0, 1.0], &#39;title&#39;: {&#39;text&#39;: &#39;x&#39;}}, &#39;yaxis&#39;: {&#39;anchor&#39;: &#39;x&#39;, &#39;domain&#39;: [0.0, 1.0], &#39;title&#39;: {&#39;text&#39;: &#39;y&#39;}}} }) . num2 . array([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100], dtype=int32) . from plotly.data import iris import plotly.express as px . df_iris = iris() . df_iris.columns . Index([&#39;sepal_length&#39;, &#39;sepal_width&#39;, &#39;petal_length&#39;, &#39;petal_width&#39;, &#39;species&#39;, &#39;species_id&#39;], dtype=&#39;object&#39;) . fig = px.scatter(data_frame=df_iris, x=&#39;sepal_length&#39;, y=&#39;petal_length&#39;, color=&#39;species&#39;, height=300, title=&#39;Comprimento de Pétalas e Sépalas&#39;) fig.show() . print(fig) . Figure({ &#39;data&#39;: [{&#39;hovertemplate&#39;: &#39;species=setosa&lt;br&gt;sepal_length=%{x}&lt;br&gt;petal_length=%{y}&lt;extra&gt;&lt;/extra&gt;&#39;, &#39;legendgroup&#39;: &#39;setosa&#39;, &#39;marker&#39;: {&#39;color&#39;: &#39;#636efa&#39;, &#39;symbol&#39;: &#39;circle&#39;}, &#39;mode&#39;: &#39;markers&#39;, &#39;name&#39;: &#39;setosa&#39;, &#39;orientation&#39;: &#39;v&#39;, &#39;showlegend&#39;: True, &#39;type&#39;: &#39;scatter&#39;, &#39;x&#39;: array([5.1, 4.9, 4.7, 4.6, 5. , 5.4, 4.6, 5. , 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5. , 5. , 5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5. , 5.5, 4.9, 4.4, 5.1, 5. , 4.5, 4.4, 5. , 5.1, 4.8, 5.1, 4.6, 5.3, 5. ]), &#39;xaxis&#39;: &#39;x&#39;, &#39;y&#39;: array([1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.6, 1.4, 1.1, 1.2, 1.5, 1.3, 1.4, 1.7, 1.5, 1.7, 1.5, 1. , 1.7, 1.9, 1.6, 1.6, 1.5, 1.4, 1.6, 1.6, 1.5, 1.5, 1.4, 1.5, 1.2, 1.3, 1.5, 1.3, 1.5, 1.3, 1.3, 1.3, 1.6, 1.9, 1.4, 1.6, 1.4, 1.5, 1.4]), &#39;yaxis&#39;: &#39;y&#39;}, {&#39;hovertemplate&#39;: &#39;species=versicolor&lt;br&gt;sepal_length=%{x}&lt;br&gt;petal_length=%{y}&lt;extra&gt;&lt;/extra&gt;&#39;, &#39;legendgroup&#39;: &#39;versicolor&#39;, &#39;marker&#39;: {&#39;color&#39;: &#39;#EF553B&#39;, &#39;symbol&#39;: &#39;circle&#39;}, &#39;mode&#39;: &#39;markers&#39;, &#39;name&#39;: &#39;versicolor&#39;, &#39;orientation&#39;: &#39;v&#39;, &#39;showlegend&#39;: True, &#39;type&#39;: &#39;scatter&#39;, &#39;x&#39;: array([7. , 6.4, 6.9, 5.5, 6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5. , 5.9, 6. , 6.1, 5.6, 6.7, 5.6, 5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6. , 5.7, 5.5, 5.5, 5.8, 6. , 5.4, 6. , 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, 5. , 5.6, 5.7, 5.7, 6.2, 5.1, 5.7]), &#39;xaxis&#39;: &#39;x&#39;, &#39;y&#39;: array([4.7, 4.5, 4.9, 4. , 4.6, 4.5, 4.7, 3.3, 4.6, 3.9, 3.5, 4.2, 4. , 4.7, 3.6, 4.4, 4.5, 4.1, 4.5, 3.9, 4.8, 4. , 4.9, 4.7, 4.3, 4.4, 4.8, 5. , 4.5, 3.5, 3.8, 3.7, 3.9, 5.1, 4.5, 4.5, 4.7, 4.4, 4.1, 4. , 4.4, 4.6, 4. , 3.3, 4.2, 4.2, 4.2, 4.3, 3. , 4.1]), &#39;yaxis&#39;: &#39;y&#39;}, {&#39;hovertemplate&#39;: &#39;species=virginica&lt;br&gt;sepal_length=%{x}&lt;br&gt;petal_length=%{y}&lt;extra&gt;&lt;/extra&gt;&#39;, &#39;legendgroup&#39;: &#39;virginica&#39;, &#39;marker&#39;: {&#39;color&#39;: &#39;#00cc96&#39;, &#39;symbol&#39;: &#39;circle&#39;}, &#39;mode&#39;: &#39;markers&#39;, &#39;name&#39;: &#39;virginica&#39;, &#39;orientation&#39;: &#39;v&#39;, &#39;showlegend&#39;: True, &#39;type&#39;: &#39;scatter&#39;, &#39;x&#39;: array([6.3, 5.8, 7.1, 6.3, 6.5, 7.6, 4.9, 7.3, 6.7, 7.2, 6.5, 6.4, 6.8, 5.7, 5.8, 6.4, 6.5, 7.7, 7.7, 6. , 6.9, 5.6, 7.7, 6.3, 6.7, 7.2, 6.2, 6.1, 6.4, 7.2, 7.4, 7.9, 6.4, 6.3, 6.1, 7.7, 6.3, 6.4, 6. , 6.9, 6.7, 6.9, 5.8, 6.8, 6.7, 6.7, 6.3, 6.5, 6.2, 5.9]), &#39;xaxis&#39;: &#39;x&#39;, &#39;y&#39;: array([6. , 5.1, 5.9, 5.6, 5.8, 6.6, 4.5, 6.3, 5.8, 6.1, 5.1, 5.3, 5.5, 5. , 5.1, 5.3, 5.5, 6.7, 6.9, 5. , 5.7, 4.9, 6.7, 4.9, 5.7, 6. , 4.8, 4.9, 5.6, 5.8, 6.1, 6.4, 5.6, 5.1, 5.6, 6.1, 5.6, 5.5, 4.8, 5.4, 5.6, 5.1, 5.1, 5.9, 5.7, 5.2, 5. , 5.2, 5.4, 5.1]), &#39;yaxis&#39;: &#39;y&#39;}], &#39;layout&#39;: {&#39;height&#39;: 300, &#39;legend&#39;: {&#39;title&#39;: {&#39;text&#39;: &#39;species&#39;}, &#39;tracegroupgap&#39;: 0}, &#39;template&#39;: &#39;...&#39;, &#39;title&#39;: {&#39;text&#39;: &#39;Comprimento de Pétalas e Sépalas&#39;}, &#39;xaxis&#39;: {&#39;anchor&#39;: &#39;y&#39;, &#39;domain&#39;: [0.0, 1.0], &#39;title&#39;: {&#39;text&#39;: &#39;sepal_length&#39;}}, &#39;yaxis&#39;: {&#39;anchor&#39;: &#39;x&#39;, &#39;domain&#39;: [0.0, 1.0], &#39;title&#39;: {&#39;text&#39;: &#39;petal_length&#39;}}} }) . sobre a necessidade de se eleger no ecossistema Python . Nos fluxos de trabalho com dados a partir do ecossistema Python, trabalhamos com uma grande quantidade de pacotes para dados matriciais/tabulares (Numpy, Pandas, Vaex etc.), plotagem de gráficos (Matplotlib, Seaborn, Bokeh, Plotly, HoloViews, etc.), processamento e visualização de dados geográficos (GeoPandas, Leaflet, Folium, Kepler, GeoViews, etc.), modelagem/machine learning (SciKit-Learn, TensorFlow, PyTorch, Keras, FastAi, etc.), deployment (Streamlit, Dash, Panel, etc.), além de uma infinidade de outros que são voltados para as mais diversas utilidades. . Em meio a tantas alternativas, é impossível que qualquer profissional seja capaz de conhecer a fundo todos os pacotes disponíveis. Assim, sobre alguns deles temos noções básicas, com outros temos um pouco mais de familiaridade, enquanto ignoramos completamente a maioria. . Diante dessa nossa incapacidade de dominar todo esse arsenal, uma estratégia bastante oportuna é escolhermos alguns poucos pacotes que serão aqueles com os quais mais trabalharemos no nosso quotidiano e nos quais desenvolveremos mais profunda proficiência. . No que tange a plotagem de produtos analíticos - gráficos, mapas e diagramas -, depois de usar diversos pacotes, eu decidi que Plotly será a arma com a qual eu tentarei ser o gatilho mais rápido do Oeste. As razões para isso ficam claras em post anterior aqui do blog. . Nesse processo de aprofundamento do conhecimento sobre a biblioteca eu procuro: . conhecer a estrutura do pacote, com o papel de cada um de seus subpacotes | ter uma boa compreensão de como está organizada a documentação | identificar as dependências do pacote e como isso afeta a sua lógica de funcionamento | saber quais são os principais objetos, seus construtores e funções relacionadas | ter uma leve noção de objetos menos utilizados, mas que eventualmente podem ser úteis | compreender caminhos para otimização do fluxo de trabalho, com vistas a ganhos de performance | . Sendo assim, nesta postagem em duas partes, o objetivo é apresentar a estrutura do Plotly, que se divide em sete subpacotes. Nesta primeira parte vamos ter uma breve noção sobre os Plotly Data, Plotly Express e plotly.colors. Na próximma, vamos tratar de Graph Objects, Subplots, I/O e Figure Factories. . . Plotly Data . Plotly Data é uma biblioteca em que podemos encontrar datasets para exercícios e práticas de elaboração de gráficos. Esses datasets conformam uma ótima maneira de se adquirir rápida prática na produção dos gráficos. Cada dataset tem uma função que o carrega em formato Pandas DataFrame, conforme podemos ver adiante, com o carregamento de dados sobre os três países com mais medalhas olímpicas em patinação de velocidade. . from plotly.data import election, medals_long, stocks # importando a função de carregamento de alguns datasets df_medals = medals_long() # declarando o dataset como Pandas Data Frame e atribuindo à variável df_medals . df_medals.head(5) # verificando as cinco primeiras linhas do Data Frame de medalhas . nation medal count . 0 South Korea | gold | 24 | . 1 China | gold | 10 | . 2 Canada | gold | 9 | . 3 South Korea | silver | 13 | . 4 China | silver | 15 | . Plotly Express . Plotly Express é uma API de alto nível de abstração, ou seja é uma interface bastante simplificada a partir da qual se é possível fazer um quantidade riquíssima de produtos analíticos - gráficos, mapas e diagramas - com apenas uma linha de código. Isso é possível pois o pacote conta com dezenas de funções com uma grande quantidade de argumentos - key-word arguments. Como esses argumentos se encontram explicitamente apresentados em cada função, a consulta de seu papel e funcionamento nas docstrings torna o trabalho muito mais fácil. Da mesma forma, os ambientes de programação - IDES, editores de texto ou Editores de Jupyter Notebooks - conseguem facilmente sugerir auto-completação dos valores, o que acelera o trabalho. . , a auto-completação , que tornam o trabalho de produção bastante intuitivo, sobretudo pois a orientação para a inserção de argumetos se encontra bem documentada e acessível no docstring e na documentação . . Lembrando que docstring são os textos instrutivos que aparecem relacionados a funções e outros objetos em Python e que são acessíveis por meio da função help, ou, no caso de em Jupyter Notebooks, pela anteposição de interrogação. . Para entendermos como funciona o subpacote, vejamos na prática como utilizá-lo para fazer um gráfico com os dados de medalhas olímpicas. Primeiramente fazemos a importação do Plotly Express como px. Em seguida, utilizando a sua função bar, indicamos df_olimpics como o data_frame a ser considerado pela função e mapeamos as colunas nation, count e medal ao eixo x, eixo y e cor, respectivamente. Por fim, inserimos o título do gráfico. . import plotly.express as px # importando plotly express como px fig_medals = px.bar( # chamando a função bard e atribuindo o gráfico à variável fig_medals data_frame=df_medals # indicação do Data Frame Olimpics como a fonte de dados para o gráfico , x=&#39;nation&#39; # mapeamento da coluna nação ao eixo x , y=&#39;count&#39; # mapeamento da coluna contagem ao eixo y , color=&#39;medal&#39; # mapeamento da coluna medalha às cores , title=&#39;Short Track Speed Skating Olympic Medals - Top Three Countries&#39; ) fig_medals.show() # chamada da renderização da figura . . . Podemos ver que, com poucas especificações, já conseguimos um resultado bastante elegante, com bela paleta de cores e com interatividade. Basta passar o cursor sobre os elementos do gráfico para se ter responsividade adequada para inserção do produto em um webapp. . Plotly Colors . Plotly colors é um subpacote que conta com escalas de cores e funções utilitárias. As paletas de cores são identificáveis em seus respectivos subpacotes: . cyclical - cores para representação de fenômenos com características cíclicas (períodos do dia, por exemplo) | diverging - cores para representação de fenômenos divergentes (PH, por exemplo) | qualitative - cores para representação de elementos dissociativos, como diferentes classes nominais (sexo masculino ou feminino, por exemplo) | sequential - cores para representação de fenômenos com gradação quantitativa ou ordenação (tamanho populacional, por exemplo) | . Em cada um desses name spaces, existe uma função bastante interessante chamada swatches - do Inglês, amostras - que renderiza as diversas paletas de cores que podem ser utilizadas como argumento na construção de gráficos, ou como fonte de consulta a códigos de cores que nos interessem. . . Em Python, name spaces se referem a domínios semânticos, ou seja o contexto em que determinado termo tem um significado, como uma variável declarada dentro de uma função que tem seu valor local, mas não global, em todo o script, ou uma função que é acessível quando importado o módulo em que está declarada, sem se confundir com outra função de mesmo nome e integrante de outro módulo. . import plotly.colors as colors colors.qualitative.swatches() . . . No caso do nosso gráfico para medalhas olímpicas, podemos notar que as cores sugeridas pelo Plotly Express são muito bonitas e correspondem às primeiras três cores do padrão Plotly Qualitative acima. Isso deve ao fato de que essa sequência de cores é aquela que é utilizada por padrão pelo pacote para dados qualitativos. Poderíamos, no entanto, ter instanciarmos o gráfico, customizando a se quência de cores, fazendo uso do argumento color_discrete_sequence e de qualquer outra paleta de cores disponível no subpacote colors, conforme o exemplo abaixo: . fig_medals = px.bar( # chamando a função bard e atribuindo o gráfico à variável fig_medals data_frame=df_medals # indicação do Data Frame Olimpics como a fonte de dados para o gráfico , x=&#39;nation&#39; # mapeamento da coluna nação ao eixo x , y=&#39;count&#39; # mapeamento da coluna contagem ao eixo y , color=&#39;medal&#39; # mapeamento da coluna medalha às cores , title=&#39;Short Track Speed Skating Olympic Medals - Top Three Countries&#39; , color_discrete_sequence=colors.qualitative.D3 ) fig_medals . . . Essas cores, embora sejam esteticamente interessantes, acarretam alguns problemas de intuitividade. Estamos representando ouro como azul, prata como laranja e bronze como verde. Em vez disso, talvez possamos consultar os swatches acima para encontrar cores que sejam mais apropriadas para o gráfico. Para tanto, basta passar o cursor sobre as cores que nos interessarem e identificaremos quais os seus códigos. Esses códigos podem, então, ser passados como parâmetros de cores de marcadores. . fig_medals.data[0].marker.color = &#39;rgb(238,232,170)&#39; fig_medals.data[1].marker.color = &#39;rgb(211,211,211)&#39; fig_medals.data[2].marker.color = &#39;rgb(205,133,63)&#39; fig_medals.show() . . . A notação fig_medals.data[0].marker.color = &#39;rgb(238,232,170)&#39; pode parecer um pouco hieroglifica a princípio. Isso porque esse tipo de notação nos dá uma primeira impressão do trabalho de mais baixo nível de abstração com os objetos Figure, que armazenam as especificações dos gráficos a serem renderizados, e até mesmo do subpacote Graph Objects que veremos na parte dois sobre a estrutura do Plotly. . . O objeto armazenado como fig_medals é justamente um Plotly Figure, um tipo que armazena instruções de dados e layout para rendereização de um gráfico. Em postagem futura vamos tratar mais a fundo do tema. . O importante agora é não nos preocuparmos com isso. Tudo ficará claro com o tempo. Por ora, basta entendermos que uma determinada característica do gráfico elaborado com Plotly Express foi alterada conforme gosto do freguês e com a ajuda da biblioteca colors e de alguns atributos específicos do objeto Figure. . Para controle de ansiedade, vejamos que essas mesmas especificações poderiam ter sido passadas diretamente na construção do gráfico a partir da função bar, com ajuda do key-word argument chamado color_discrete_map. . fig_medals2 = px.bar( # chamando a função bard e atribuindo o gráfico à variável fig_medals data_frame=df_medals # indicação do Data Frame Olimpics como a fonte de dados para o gráfico , x=&#39;nation&#39; # mapeamento da coluna nação ao eixo x , y=&#39;count&#39; # mapeamento da coluna contagem ao eixo y , color=&#39;medal&#39; # mapeamento da coluna medalha às cores , title=&#39;Short Track Speed Skating Olympic Medals - Top Three Countries&#39; , color_discrete_map={&#39;gold&#39;:&#39;rgb(238,232,170)&#39;, &#39;bronze&#39;:&#39;rgb(205,133,63)&#39;, &#39;silver&#39;:&#39;rgb(211,211,211)&#39;} #especificação de cores ) fig_medals2.show() # chamada da renderização da figura . . . Riscando a Superf&#237;cie . Até aqui conseguimos ter uma visão bastante introdutória de três dos setes subpacotes do Plotly, com os quais podemos obter datasets para nossos exercícios, fazer gráficos com apenas a chamada de uma função e acesso a paleta de cores para customização. Cada um desses pacotes tem muito mais a oferecer, mas aqui já conseguimos ter uma ideia geral. Na sequência, vamos avançar sobre os demais subpacotes, o que vai nos dar uma boa compreensão da estrutura do Plotly, um passo importante para nossa proficiência com a ferramenta. .",
            "url": "https://augustogeog.github.io/augustogeog/plotly/gr%C3%A1ficos/python/2021/06/04/estrutura-plotly-part2.html",
            "relUrl": "/plotly/gr%C3%A1ficos/python/2021/06/04/estrutura-plotly-part2.html",
            "date": " • Jun 4, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Começando a Fazer Produtos Gráficos com Plotly",
            "content": "O Desafio do Trabalho com Gr&#225;ficos em Python . Elaborar gráficos, mapas e diagramas compõe uma das atividades mais rotineiras nos fluxos de trabalhos intensivos em tecnologias para dados. Ainda assim, a tarefa é frequentemente difícil, mesmo em um ecossistema de dados maduro como aquele em Python. Nas diversas bibliotecas disponíveis, a área do gráfico, o plano de fundo, os eixos, as anotações, o título, o tipo de representação, a escala numérica, a interatividade, entre tantas outras coisas, são extremamente customizáveis, o que é muito positivo do ponto de vista da versatilidade, mas o que também tem seu preço em termos de complexidade das bibliotecas. Trata-se de uma complexidade que pode ser ainda maior a depender da biblioteca utilizada, a considerar que algumas mais verborrágicas do que as outras - sim, Matplotlib, estou falando com você! . Por isso, descobrir como alterar atributos simples dos gráficos pode demandar um precioso tempo dos desenvolvedores/analistas. Sem falar nos possíveis erros inesperados, como incompatibilidades de ferramentas - tente fazer publicação de um gráfico cheio de subplots com Altair para deployment via Streamlit e você estará a caminho de noites em claro lendo posts no StackOverflow. Nesse sentido, os profissionais que trabalham com dados no ecossistema Python precisam estar bem a par dos potenciais e limitações de cada ferramenta, tendo uma visão geral de sua aplicação e até mesmo da sua compatibilidade com as demais bibliotecas que serão utilizadas no fluxo de trabalho. . Se assim é, então vamos olhar adiante o que é a biblioteca Plotly, uma ferramenta bastante robusta e poderosa em mãos bem preparadas. . . Bibliotecas verborrágicas são aquelas que exigem muitas linhas de código para pequenas operações. . O que &#233; Plotly . Plotly é uma biblioteca para plotagem de gráficos, mapas e diagramas interativos e otimizados para aplicações web. Como tal, ela é , com versões disponíveis nas linguagens Python, JavaScript, Julia e R. A Como se trata de uma solução principalmente para web, a renderização dos gráficos é realizada em JavaScript, sendo que as versões em outras linguagens são utilizadas para gerar as instruções para aquela linguagem. . É uma linguagem declarativa, ou seja, a sua lógica é a de declaração dos valores a serem plotados em relação ao tipo de representação que esperamos deles. Assim, codificamos os valores a um tipo de gráfico - barras, scatter, linhas, etc. -, destacando quais valores, como aqueles das colunas de um data frame, a variações no eixo x, enquanto associamos outros a variações no eixo y, a cores, tamanhos, formas, e assim sucessivamente. . Os pontos fortes da biblioteca são: . a beleza e elegância dos layouts | a ampla gama tipos de gráficos, mapas e diagramas | os recursos de interatividade | a compatibilidade com diversos recursos para deployment na web, inclusive com recursos próprios via biblioteca Dash | a integração as demais ferramentas do ecossistema de dados em Python | a infinidade de customizações possíveis nos mais diversos atributos | a ativa comunidade disposta a responder questões on-line | a documentação consistente e bem estruturada | a rápida curva de aprendizado para produção dos primeiros gráficos | Veja abaixo a qualidade dos gráficos que podem ser feitos com a biblioteca: . . Como ponto negativo, encontramos a complexidade para entendimento do funcionamento dos recursos de mais baixo nível de abstração, necessários quando se pretende fazer customizações em detalhes dos produtos gráficos. . Plotly Express . Por falar em pontos positivos, a rápida implementação de gráficos bastante arrojados é garantida por uma API de alto nível de abstração chamada Plotly Express. Para não ficar nas minhas palavras, vejamos adiante: . import pandas as pd # importando Pandas para manipular dados tabulares import plotly.express as px # importando plotly express. A prática é dar alias px df = pd.read_csv( &#39;https://raw.githubusercontent.com/augustogeog/augustogeog/master/assets/data/pop_long.csv&#39; , sep=&#39;;&#39;) # carregando dados populacionais de São José dos Pinhais/PR em Pandas Data Frame df # chamando o Data Frame . CodMun Municipio Ano Situação População . 0 4125506 | São José dos Pinhais | 1970 | Total | 34124 | . 1 4125506 | São José dos Pinhais | 1980 | Total | 70643 | . 2 4125506 | São José dos Pinhais | 1991 | Total | 127455 | . 3 4125506 | São José dos Pinhais | 2000 | Total | 204316 | . 4 4125506 | São José dos Pinhais | 2010 | Total | 264210 | . 5 4125506 | São José dos Pinhais | 1970 | Urbana | 21529 | . 6 4125506 | São José dos Pinhais | 1980 | Urbana | 56814 | . 7 4125506 | São José dos Pinhais | 1991 | Urbana | 111952 | . 8 4125506 | São José dos Pinhais | 2000 | Urbana | 183366 | . 9 4125506 | São José dos Pinhais | 2010 | Urbana | 236895 | . 10 4125506 | São José dos Pinhais | 1970 | Rural | 12595 | . 11 4125506 | São José dos Pinhais | 1980 | Rural | 13829 | . 12 4125506 | São José dos Pinhais | 1991 | Rural | 15503 | . 13 4125506 | São José dos Pinhais | 2000 | Rural | 20950 | . 14 4125506 | São José dos Pinhais | 2010 | Rural | 27315 | . Acima, importamos para Pandas DataFrame os dados populacionais conforme os levantamentos censitários de 1970 a 2010 para São José dos Pinhais. Com esses dados atribuídos à variável df, podemos passar à produção de um gráfico de linhas que mostre a variação demográfica urbana, rural e total no período: . fig = px.line(data_frame=df, x=&#39;Ano&#39;, y=&#39;População&#39;, color=&#39;Situação&#39;, title=&#39;Crescimento Populacional em São José dos Pinhais/PR&#39;) fig.show() #Método show para renderização do gráfico . . . Como se pode ver, com poucas linhas de código, foi possível fazer um belo gráfico da evolução populacional de São José dos Pinhais/PR. A plotagem em si foi feita em apenas uma linha, com a função line, que recebeu o data frame a ser plotado, o nome da colunas a sere mapeadas aos eixos x, y e à cores, além do título do produto analítico. Fácil, não? . Essa mesma função possui mais de 30 outros atributos para customização de tipo de linhas, rótulos, escala dos eixos, largura e altura do gráfico, tipo de linha, intervalo dos eixos, paleta de cores, animação etc. Como ela, outras dezenas de funções do Plotly Express permitem a elaboração de gráficos de área, barras, histogramas, de dispersão, tridimensionais, mapas etc. . O mais interessante é que as funções são muito parecidas. Quer um gráfico de linhas? Função line. Precisa de um scatter plot? Função scatter. Está precisando impressionar a turma do escritório com um cartograma interativo sobre base do GoogleMaps? Função choropleth_mapbox ao seu socorro. Cada uma dessas funções, por lidar com tipos diferentes de produtos analíticos, apresenta algumas poucas opções próprias ao seu tipo de gráfico. . Um detalhe importante no uso da biblioteca Plotly é que ela está mais adequada para trabalhar com tabelas em formato longo (long), como foi aquela do exemplo acima, para a população de São José dos Pinhais. A tabela abaixo apresenta os mesmos dados, porém arranjados em formato largo (wide). Aparentemente Plotly passou a aceitar recentemente o uso de tabelas wide, mas recomenda-se o formato longo por ser mais intuitivo na hora de associar as colunas aos atributos dos gráficos. . df_wide = pd.read_csv(&#39;https://raw.githubusercontent.com/augustogeog/augustogeog/master/assets/data/pop_wide.csv&#39;, sep=&#39;;&#39;) df_wide . CodMun Municipio Ano Total Urbana Rural . 0 4125506 | São José dos Pinhais | 1970 | 34124 | 21529 | 12595 | . 1 4125506 | São José dos Pinhais | 1980 | 70643 | 56814 | 13829 | . 2 4125506 | São José dos Pinhais | 1991 | 127455 | 111952 | 15503 | . 3 4125506 | São José dos Pinhais | 2000 | 204316 | 183366 | 20950 | . 4 4125506 | São José dos Pinhais | 2010 | 264210 | 236895 | 27315 | . Isso, porém, não é um grande empecilho, uma vez que é muito fácil transformar uma tabela larga em uma tabela longa, conforme podemos ver abaixo - Pandas, seu lindo! . df_wide.melt(id_vars=[&#39;CodMun&#39;, &#39;Municipio&#39;, &#39;Ano&#39;], var_name=&#39;Situação&#39;, value_name=&#39;População&#39;) . CodMun Municipio Ano Situação População . 0 4125506 | São José dos Pinhais | 1970 | Total | 34124 | . 1 4125506 | São José dos Pinhais | 1980 | Total | 70643 | . 2 4125506 | São José dos Pinhais | 1991 | Total | 127455 | . 3 4125506 | São José dos Pinhais | 2000 | Total | 204316 | . 4 4125506 | São José dos Pinhais | 2010 | Total | 264210 | . 5 4125506 | São José dos Pinhais | 1970 | Urbana | 21529 | . 6 4125506 | São José dos Pinhais | 1980 | Urbana | 56814 | . 7 4125506 | São José dos Pinhais | 1991 | Urbana | 111952 | . 8 4125506 | São José dos Pinhais | 2000 | Urbana | 183366 | . 9 4125506 | São José dos Pinhais | 2010 | Urbana | 236895 | . 10 4125506 | São José dos Pinhais | 1970 | Rural | 12595 | . 11 4125506 | São José dos Pinhais | 1980 | Rural | 13829 | . 12 4125506 | São José dos Pinhais | 1991 | Rural | 15503 | . 13 4125506 | São José dos Pinhais | 2000 | Rural | 20950 | . 14 4125506 | São José dos Pinhais | 2010 | Rural | 27315 | . Explorando o Potencial do Plotly Express . Agora que temos uma leve ideia de como funciona o subpacote Express do Plotly, podemos explorar um pouco mais a fundo o potencial dessa formidável API. Adiante, vamos obter dados do instituto GapMinder: . url = &#39;https://raw.githubusercontent.com/plotly/datasets/master/gapminderDataFiveYear.csv&#39; #url dos dados df_gapminder = pd.read_csv(url) #importando os dados para um Pandas DataFrame df_gapminder #Fazendo uma breve exploração preliminar dos dados . country year pop continent lifeExp gdpPercap . 0 Afghanistan | 1952 | 8425333.0 | Asia | 28.801 | 779.445314 | . 1 Afghanistan | 1957 | 9240934.0 | Asia | 30.332 | 820.853030 | . 2 Afghanistan | 1962 | 10267083.0 | Asia | 31.997 | 853.100710 | . 3 Afghanistan | 1967 | 11537966.0 | Asia | 34.020 | 836.197138 | . 4 Afghanistan | 1972 | 13079460.0 | Asia | 36.088 | 739.981106 | . ... ... | ... | ... | ... | ... | ... | . 1699 Zimbabwe | 1987 | 9216418.0 | Africa | 62.351 | 706.157306 | . 1700 Zimbabwe | 1992 | 10704340.0 | Africa | 60.377 | 693.420786 | . 1701 Zimbabwe | 1997 | 11404948.0 | Africa | 46.809 | 792.449960 | . 1702 Zimbabwe | 2002 | 11926563.0 | Africa | 39.989 | 672.038623 | . 1703 Zimbabwe | 2007 | 12311143.0 | Africa | 43.487 | 469.709298 | . 1704 rows × 6 columns . Em seguida, vamos fazer um scatter plot dinâmico, que será capaz de mostrar diferentes anos pela reprodução sequencial de frames. . fig2 = px.scatter( data_frame=df_gapminder # indicação do DataFrame cujos dados serão plotados , x=&#39;gdpPercap&#39; # mapeamento da coluna PIB Percapita ao eixo x , y=&#39;lifeExp&#39; # mapeamento da coluna de expectativa de vida ao eixo y , color=&#39;continent&#39; # mapeamento do continente à cor , size=&#39;pop&#39; # mapeamento da população ao tamanho dos círculos , animation_frame=&#39;year&#39; # mapeamento do ano aos frames de animação , log_x=True # uso da escala logarítmica no eixo x , size_max=50 # seleção do tamanho máximo dos círculos , range_y=[25,100] # estabelecimento do valor mínimo e máximo do eixo y , hover_name=&#39;country&#39; ) fig2.show() # chamando a visualização do gráfico . . . Para elaborar esse gráfico elegante, tudo o que tivemos que fazer foi chamar uma única função, scatter. Todas os atributos que precisamos alterar se encontravam dentro da função, o que se torna tudo mais fácil. Assim indicamos que o data frame a ser plotado era o df_gapminder, associamos a coluna gdpPercap ao eixo x, lifeExp ao eixo y, continent à variação de cores, pop ao tamanho dos círculos, year à animação, transformamos o eixo x em escala logarítmica, indicamos o tamanho máximo dos círculos e estabelecemos os limites inferior e superior do eixo y. . Palavra de Amigo . Depois dessa breve introdução, só resta deixar uma palavra de amigo: adote Plotly no seu fluxo de trabalho com dados. A biblioteca é muito poderosa, intuitiva e vai valorizar muito o seus projetos! . PS: I Love You . Hei, Matplotlib, não fica triste. Eu sei do seu papel na comunidade. Não leva a mão o lance de te chamar de verborrágico. Com amor, Augusto. .",
            "url": "https://augustogeog.github.io/augustogeog/plotly/gr%C3%A1ficos/python/2021/05/31/introdu%C3%A7%C3%A3o-plotly.html",
            "relUrl": "/plotly/gr%C3%A1ficos/python/2021/05/31/introdu%C3%A7%C3%A3o-plotly.html",
            "date": " • May 31, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Conhecendo a Estrutura do Plotly (Parte 1)",
            "content": "Profici&#234;ncia no Uso das Ferramentas . Nos fluxos de trabalho com dados a partir do ecossistema Python, trabalhamos com uma grande quantidade de pacotes para dados matriciais/tabulares (Numpy, Pandas, Vaex etc.), plotagem de gráficos (Matplotlib, Seaborn, Bokeh, Plotly, HoloViews, etc.), processamento e visualização de dados geográficos (GeoPandas, Leaflet, Folium, Kepler, GeoViews, etc.), modelagem/machine learning (SciKit-Learn, TensorFlow, PyTorch, Keras, FastAi, etc.), deployment (Streamlit, Dash, Panel, etc.), além de uma infinidade de outros que são voltados para as mais diversas utilidades. . Em meio a tantas alternativas, é impossível que qualquer profissional seja capaz de conhecer a fundo todos os pacotes disponíveis. Assim, sobre alguns deles temos noções básicas, com outros temos um pouco mais de familiaridade, enquanto ignoramos completamente a maioria. . Diante dessa nossa incapacidade de dominar todo esse arsenal, uma estratégia bastante oportuna é escolhermos alguns poucos pacotes que serão aqueles com os quais mais trabalharemos no nosso quotidiano e nos quais desenvolveremos mais profunda proficiência. . No que tange a plotagem de produtos analíticos - gráficos, mapas e diagramas -, depois de usar diversos pacotes, eu decidi que Plotly será a arma com a qual eu tentarei ser o gatilho mais rápido do Oeste. As razões para isso ficam claras em post anterior aqui do blog. . Nesse processo de aprofundamento do conhecimento sobre a biblioteca eu procuro: . conhecer a estrutura do pacote, com o papel de cada um de seus subpacotes | ter uma boa compreensão de como está organizada a documentação | identificar as dependências do pacote e como isso afeta a sua lógica de funcionamento | saber quais são os principais objetos, seus construtores e funções relacionadas | ter uma leve noção de objetos menos utilizados, mas que eventualmente podem ser úteis | compreender caminhos para otimização do fluxo de trabalho, com vistas a ganhos de performance | . Sendo assim, nesta postagem em duas partes, o objetivo é apresentar a estrutura do Plotly, que se divide em sete subpacotes. Nesta primeira parte vamos ter uma breve noção sobre os Plotly Data, Plotly Express e plotly.colors. Na próximma, vamos tratar de Graph Objects, Subplots, I/O e Figure Factories. . . Plotly Data . Plotly Data é uma biblioteca em que podemos encontrar datasets para exercícios e práticas de elaboração de gráficos. Esses datasets conformam uma ótima maneira de se adquirir rápida prática na produção dos gráficos. Cada dataset tem uma função que o carrega em formato Pandas DataFrame, conforme podemos ver adiante, com o carregamento de dados sobre os três países com mais medalhas olímpicas em patinação de velocidade. . from plotly.data import election, medals_long, stocks # importando a função de carregamento de alguns datasets df_medals = medals_long() # declarando o dataset como Pandas Data Frame e atribuindo à variável df_medals . df_medals.head(5) # verificando as cinco primeiras linhas do Data Frame de medalhas . nation medal count . 0 South Korea | gold | 24 | . 1 China | gold | 10 | . 2 Canada | gold | 9 | . 3 South Korea | silver | 13 | . 4 China | silver | 15 | . Plotly Express . Plotly Express é uma API de alto nível de abstração, ou seja é uma interface bastante simplificada a partir da qual se é possível fazer um quantidade riquíssima de produtos analíticos - gráficos, mapas e diagramas - com apenas uma linha de código. Isso é possível pois o pacote conta com dezenas de funções com uma grande quantidade de argumentos - key-word arguments. Como esses argumentos se encontram explicitamente apresentados em cada função, a consulta de seu papel e funcionamento nas docstrings torna o trabalho muito mais fácil. Da mesma forma, os ambientes de programação - IDES, editores de texto ou Editores de Jupyter Notebooks - conseguem facilmente sugerir auto-completação dos valores, o que acelera o trabalho. . , a auto-completação , que tornam o trabalho de produção bastante intuitivo, sobretudo pois a orientação para a inserção de argumetos se encontra bem documentada e acessível no docstring e na documentação . . Lembrando que docstring são os textos instrutivos que aparecem relacionados a funções e outros objetos em Python e que são acessíveis por meio da função help, ou, no caso de em Jupyter Notebooks, pela anteposição de interrogação. . Para entendermos como funciona o subpacote, vejamos na prática como utilizá-lo para fazer um gráfico com os dados de medalhas olímpicas. Primeiramente fazemos a importação do Plotly Express como px. Em seguida, utilizando a sua função bar, indicamos df_olimpics como o data_frame a ser considerado pela função e mapeamos as colunas nation, count e medal ao eixo x, eixo y e cor, respectivamente. Por fim, inserimos o título do gráfico. . import plotly.express as px # importando plotly express como px fig_medals = px.bar( # chamando a função bard e atribuindo o gráfico à variável fig_medals data_frame=df_medals # indicação do Data Frame Olimpics como a fonte de dados para o gráfico , x=&#39;nation&#39; # mapeamento da coluna nação ao eixo x , y=&#39;count&#39; # mapeamento da coluna contagem ao eixo y , color=&#39;medal&#39; # mapeamento da coluna medalha às cores , title=&#39;Short Track Speed Skating Olympic Medals - Top Three Countries&#39; ) fig_medals.show() # chamada da renderização da figura . . . Podemos ver que, com poucas especificações, já conseguimos um resultado bastante elegante, com bela paleta de cores e com interatividade. Basta passar o cursor sobre os elementos do gráfico para se ter responsividade adequada para inserção do produto em um webapp. . Plotly Colors . Plotly colors é um subpacote que conta com escalas de cores e funções utilitárias. As paletas de cores são identificáveis em seus respectivos subpacotes: . cyclical - cores para representação de fenômenos com características cíclicas (períodos do dia, por exemplo) | diverging - cores para representação de fenômenos divergentes (PH, por exemplo) | qualitative - cores para representação de elementos dissociativos, como diferentes classes nominais (sexo masculino ou feminino, por exemplo) | sequential - cores para representação de fenômenos com gradação quantitativa ou ordenação (tamanho populacional, por exemplo) | . Em cada um desses name spaces, existe uma função bastante interessante chamada swatches - do Inglês, amostras - que renderiza as diversas paletas de cores que podem ser utilizadas como argumento na construção de gráficos, ou como fonte de consulta a códigos de cores que nos interessem. . . Em Python, name spaces se referem a domínios semânticos, ou seja o contexto em que determinado termo tem um significado, como uma variável declarada dentro de uma função que tem seu valor local, mas não global, em todo o script, ou uma função que é acessível quando importado o módulo em que está declarada, sem se confundir com outra função de mesmo nome e integrante de outro módulo. . import plotly.colors as colors colors.qualitative.swatches() . . . No caso do nosso gráfico para medalhas olímpicas, podemos notar que as cores sugeridas pelo Plotly Express são muito bonitas e correspondem às primeiras três cores do padrão Plotly Qualitative acima. Isso deve ao fato de que essa sequência de cores é aquela que é utilizada por padrão pelo pacote para dados qualitativos. Poderíamos, no entanto, ter instanciarmos o gráfico, customizando a se quência de cores, fazendo uso do argumento color_discrete_sequence e de qualquer outra paleta de cores disponível no subpacote colors, conforme o exemplo abaixo: . fig_medals = px.bar( # chamando a função bard e atribuindo o gráfico à variável fig_medals data_frame=df_medals # indicação do Data Frame Olimpics como a fonte de dados para o gráfico , x=&#39;nation&#39; # mapeamento da coluna nação ao eixo x , y=&#39;count&#39; # mapeamento da coluna contagem ao eixo y , color=&#39;medal&#39; # mapeamento da coluna medalha às cores , title=&#39;Short Track Speed Skating Olympic Medals - Top Three Countries&#39; , color_discrete_sequence=colors.qualitative.D3 ) fig_medals . . . Essas cores, embora sejam esteticamente interessantes, acarretam alguns problemas de intuitividade. Estamos representando ouro como azul, prata como laranja e bronze como verde. Em vez disso, talvez possamos consultar os swatches acima para encontrar cores que sejam mais apropriadas para o gráfico. Para tanto, basta passar o cursor sobre as cores que nos interessarem e identificaremos quais os seus códigos. Esses códigos podem, então, ser passados como parâmetros de cores de marcadores. . fig_medals.data[0].marker.color = &#39;rgb(238,232,170)&#39; fig_medals.data[1].marker.color = &#39;rgb(211,211,211)&#39; fig_medals.data[2].marker.color = &#39;rgb(205,133,63)&#39; fig_medals.show() . . . A notação fig_medals.data[0].marker.color = &#39;rgb(238,232,170)&#39; pode parecer um pouco hieroglifica a princípio. Isso porque esse tipo de notação nos dá uma primeira impressão do trabalho de mais baixo nível de abstração com os objetos Figure, que armazenam as especificações dos gráficos a serem renderizados, e até mesmo do subpacote Graph Objects que veremos na parte dois sobre a estrutura do Plotly. . . O objeto armazenado como fig_medals é justamente um Plotly Figure, um tipo que armazena instruções de dados e layout para rendereização de um gráfico. Em postagem futura vamos tratar mais a fundo do tema. . O importante agora é não nos preocuparmos com isso. Tudo ficará claro com o tempo. Por ora, basta entendermos que uma determinada característica do gráfico elaborado com Plotly Express foi alterada conforme gosto do freguês e com a ajuda da biblioteca colors e de alguns atributos específicos do objeto Figure. . Para controle de ansiedade, vejamos que essas mesmas especificações poderiam ter sido passadas diretamente na construção do gráfico a partir da função bar, com ajuda do key-word argument chamado color_discrete_map. . fig_medals2 = px.bar( # chamando a função bard e atribuindo o gráfico à variável fig_medals data_frame=df_medals # indicação do Data Frame Olimpics como a fonte de dados para o gráfico , x=&#39;nation&#39; # mapeamento da coluna nação ao eixo x , y=&#39;count&#39; # mapeamento da coluna contagem ao eixo y , color=&#39;medal&#39; # mapeamento da coluna medalha às cores , title=&#39;Short Track Speed Skating Olympic Medals - Top Three Countries&#39; , color_discrete_map={&#39;gold&#39;:&#39;rgb(238,232,170)&#39;, &#39;bronze&#39;:&#39;rgb(205,133,63)&#39;, &#39;silver&#39;:&#39;rgb(211,211,211)&#39;} #especificação de cores ) fig_medals2.show() # chamada da renderização da figura . . . Riscando a Superf&#237;cie . Até aqui conseguimos ter uma visão bastante introdutória de três dos setes subpacotes do Plotly, com os quais podemos obter datasets para nossos exercícios, fazer gráficos com apenas a chamada de uma função e acesso a paleta de cores para customização. Cada um desses pacotes tem muito mais a oferecer, mas aqui já conseguimos ter uma ideia geral. Na sequência, vamos avançar sobre os demais subpacotes, o que vai nos dar uma boa compreensão da estrutura do Plotly, um passo importante para nossa proficiência com a ferramenta. .",
            "url": "https://augustogeog.github.io/augustogeog/plotly/gr%C3%A1ficos/python/2021/05/31/estrutura-plotly.html",
            "relUrl": "/plotly/gr%C3%A1ficos/python/2021/05/31/estrutura-plotly.html",
            "date": " • May 31, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "A Cidade e as Ondas Tecnológicas",
            "content": "As Mudan&#231;as Tecnol&#243;gicas e as Transforma&#231;&#245;es da Cidade . A cidade apresenta um conjunto enorme de desafios de toda ordem - ambientais, sociais, econômicos, simbólicos, de infraestrutura etc. Há alguns séculos, esses conjuntos de desafios tomam diferentes qualidades e ordens de grandeza conforme o decorrer de sucessivos paradigmas técno-econômicos, ou seja, segundo a prevalência de ciclos em que certas famílias tecnológicas dão a tônica da modernização econômica. . Durante o paradigma das máquinas a vapor, a modernização correspondeu à automação de processos com base na difusão de caldeiras que utilizavam a queima de carvão para movimentar maquinários, à moda dos teares de Birmingham e Manchester. Nesse contexto, a tecnologia se expandiu e modernizou tanto a produção como os transportes, com os trens e barcos a vapor. Como consequência desse processo, a cidade mudou em seu conteúdo (presença de unidades industriais, aporte de imigrantes rurais para trabalho no setor secundário etc.), função (novo papel de fornecimento de produtos industrializados), estrutura (formação de bairros industriais, bairros operários, áreas de entrepostos logísticos no entorno de estações ferroviárias etc.), forma (extravasamento de limites prévios segundo a onda de crescimento da mancha urbana, a partir das novas instalações industriais e populares) e articulação interurbana (crescimento da influência da cidade sobre vastas áreas a partir das interconexões ferroviárias e ampliação dos fluxos portuários). . . Figura: Paradigma Técnico das Máquinas a Vapor e a Cidade Tear de james hargreaves. Fonte: https://snl.no/Spinning_Jenny . Máquina a Vapor de Watt. Fonte: https://www.independent.co.uk . Linha Férrea de Stockton and Darlington. Fonte: https://www.independent.co.uk . Área Industrial em Manchester. Fonte: https://teesvalleymuseums.org . Esse padrão de mudanças no conteúdo, função, estrutura, forma e articulação interurbana das cidades é um elemento comum no processo de sucessão dos paradigmas tecno-econômicos. No paradigma formado pela ascensão das tecnologias siderúrgica, automobilística e elétrica, a cidade também passou por significativas mudanças. Os automóveis tiveram importante papel em sua reconfiguração, ensejando a expansão de seu tecido, pela ocupação habitacional cada vez mais distante do centro. A eletricidade, aplicada a elevadores, permitiu a construção de edifícios cada vez mais altos. A consequente valorização de andares superiores diminuiu um padrão comum em algumas cidades europeias do século XIX, em que pobres habitavam andares superiores e pessoas com melhores condições de renda habitavamm os andares inferiores. Essa dinâmica se somou a uma racionalização das estratégias locacionais, de forma que houve aumento significativo da segregação socioespacial. As atividades culturais e sociais noturnas também ganharam grande impulso, com maior capacidade de iluminação pública e de edifícios de eventos, como teatros e cinemas. . A proliferação de mais avançadas tecnologias de telecomunicações e de informática, desde a década de 1970, também trouxe grandes impactos para as condições urbanas, sobretudo no reforço ao papel da cidade como centro provedor de serviços. É nesse momento que a articulação das redes de cidades toma proporções ainda maiores, em escala global. Isso permitiu uma reconfiguração dos papeis urbanos, a partir de uma nova divisão internacional do trabalho, em que o comando dos negócios das empresas transnacionais, além da pesquisa e o do desenvolvimento, mantiveram-se nas grandes cidades dos países centrais, enquanto, em países periféricos, ocorreu uma onda de industrialização e de metropolização. . Em todos esses movimentos de mudanças tecno-econômicas, a cidade foi palco de grandes transformações nas mais diversas dimensões da vida em sociedade, o que gera inúmeros desafios - poluição, reestruturação econômica, desigualdades etc. Um dos elementos marcantes do processo é a ocorrência de uma fase bastante abruta de difusão tecnológica, em que a sinalização de elevada lucratividade forma um sistema de incentivos para que o novo padrão de tecnologias seja adotado. A figura abaixo pode justamente demonstrar isso. Nela, pode-se observar que, em 1900, a célebre Quinta Avenida, Nova Iorque, está tomada por charretes puxadas por cavalos, havendo apenas um automóvel. Treze anos depois, a situação é inversa, com apenas uma charrete sendo avistada em meio a dezenas de automóveis. . Figura: Abrupta mudança em Nova Iorque, entre 1900, com predomínio de charretes, e 1913, com automóveis Fonte: https://mashable.com/ . Em face de tal situação, podemos pensar os efeitos sobre as cadeias de negócios. Os relatos apontam que, em 1900, Nova Iorque contava com aproximadamente 100 mil cavalos, muitos dos quais eram utilizados em juntas para movimento de grandes vagões para transporte público. Nesse contexto, não é difícil se imaginar os efeitos da sua radical substituição por automóveis, tais como perda de empregos nas cadeias baseadas na tração animal - estábulos, cuidados animais, fornecimento de alimentos e os próprios serviços de cocheiros -, bem como surgimento de novas cadeias de negócios e empregos - fornecimento de combustíveis, oficinas de reparos, motoristas etc. Em todo caso, não há garantia de imediata realocação da força de trabalho de um ramo em declínio em outro, em ascensão. Há que se ressaltar, também, que o grande número de animais trazia problemas de poluição das ruas, razão pela qual os automóveis eram grandemente observados como soluções limpas para o transporte urbano. . Clique aqui para detalhes sobre paradigmas tecno-econômicos O conceito de paradigmas tecno-econômicos é uma construção de economistas neo-schumpeterianos, como Giovanni Dosi, Christopher Freeman e Carlota Perez. O conceito é uma evolução da ideia de paradigmas científicos, de Thomas Kuhn, dos ciclos econômicos, de Nikolai Kondratiev, bem como de centralidade da inovação no rompimento do equilíbrio de mercado no capitalismo e na explicação de base técnica para os ciclos econômicos, conforme teoria de Joseph Schumpeter. Segundo os autores, a ocorrência dos paradigmas é caracterizada por diferentes fases: preliminar - momento de experimentação de diferentes soluções técnicas ainda não claramente viáveis -; de instalação - quando a viabilidade de uma determinada família se apresenta e é colocada em prática ainda em escala reduzida -; crescimento - situação em que super-lucros se mostram viáveis, havendo grande atração de investimentos e difusão das soluções técnicas, com modernização dos mais diversos ramos econômicos -; e maturidade - etapa em que a família de tecnologias já se encontra bastante difundida, com consequente diminuição do estímulo para novos investimentos. Cabe destacar que, para Carlota Perez, até o momento, o capitalismo teria passado por quatro desses ciclos, estando em meio ao quinto. Para a autora, o primeiro paradigma, dos teares mecânicos, baseados nas rodas de água, é distinto daquele seguinte, com a inserção das máquinas a vapor. Para simplificação dos argumentos no presente texto, não houve acima devida distinção de ambos. . A Atual Onda T&#233;cnica e seus Desafios Urbanos . Na atualidade, uma nova família de tecnologias se encontra em desenvolvimento, arregimentando investimentos, pesquisa, qualificação profissional, empenho de empreendedores e fomento estatal. Ainda está para se confirmar o papel de algumas técnicas como parte desse grupo de padrões de soluções altamente penetrantes e modernizadoras da economia - impressão 3D, seria um exemplo. Seja como for, parece certo que as soluções intensivas em dados conformam o core dessa onda tecnológica. Soluções intensivas em dados é um termo bastante generalista aqui para denotar todo o avanço tecnológico que tem ocorrido na produção, armazenamento, obtenção, tratamento, análise e modelagem de dados computacionais nos mais diversos formatos. . O imenso volume de dados produzido pelas mais diversas fontes - websites, internet das coisas, redes sociaisa etc. -, a enorme capacidade de processamento por soluções em nuvem - ao que se somará a transmissão de alta velocidade por 5G - e a recente convergência de interesses em algoritmos de redes neurais criaram o cenário presente em que soluções baseadas em machine learning e, sobretudo, em deep learning se tornassem viáveis para renovação de modelos de negócios em praticamente todos os ramos da economia. . O combustível dessa máquina modernizadora dos negócios são os dados. Uma vez bem coletados, armazenados, tratados e classificados, os mais diversos tipos de dados - textos, imagens, vídeos, sons, registros tabulares etc. - podem servir para aplicações significativamente inovadoras. Coleções de imagens médicas têm garantido a geração de mecanismos de diagnósticos, prognósticos e, até mesmo, a identificação de padrões na evolução de doenças que não tinham sido anteriormente descobertos nas pesquisas de saúde. Os registros dos comportamentos dos consumidores têm permitido a formação de grupos com diferentes perfis de consumo, bem como adequação dos sistemas de sugestão de produtos e serviços. Dados de celulares são referência para previsão de trânsito e sugestão de rotas. Os exemplos podem se somar aqui exaustivamente. . Essa dinâmica de grandes volumes de dados aplicados a novas soluções tem criado as condições para o desenvolvimento daquilo que, na cidade, tende a ser o grande marco da atual onda tecnológica no espaço urbano, o carro elétrico autônomo. Esse tipo de veículo, confirmadas as tendências, impactará significativamente as cidades, uma vez que será menos um automóvel com computador e mais um grande computador com rodas. Nesse sentido, as otimizações de uso serão notáveis. Enquanto a maioria da frota tradicional é composta por veículos que passam a maior parte do tempo parados, um veículo autônomo poderá passar o dia todo atendendo a viagens solicitadas por aplicativos. O efeito disso sobre os preços das corridas, a considerar também as diminuições de custos mecânicos e com energia elétrica, podem servir de incentivo para que as pessoas não tenham automóveis, mas usem cada vez mais serviços semelhantes ao Uber. Na prática, mais movimento na cidade, com menos automóveis. . . Parece distante? Não nos esqueçamos da abruta mudança das charretes para os automóveis em Nova Iorque! . Figura: Carro autônomo identificando rotas e objetos em vias Fonte: https://wikipedia.com/ . Por outro lado, o efeito disso sobre toda a cadeia de negócios voltadas para os automóveis tradicionais pode ser afetada, com inviabilidade de empresas já estabelecidas e perda de empregos. Isso se torna ainda mais severo a se considerar a grande quantidade de pessoas que atualmente dependem de trabalhos como motoristas por aplicativos e que podem deixar de ter seu emprego. Ao mesmo tempo, a infraestrutura viária também pode ser afetada. Para manutenção da segurança e garantia da fluidez do trânsito, não seria estranho pensar que não só os automóveis deverão manter ativa obtenção de informações do entorno para decisões de trajetos e comportamento em situações de perigo de atropelamento ou de colisão. Nesses casos, é possível se vislumbrar que a própria infraestrutura viária possa ser dotada de mecanismos para envio de sinais aos automóveis autônomos, com protocolos locais para soluções de eventuais problemas, como ordem de precedência para saída de engarrafamentos, ou abertura de espaço para veículos de resgate. . . O efeito disruptivo de inovações como o carro autônomo é a base do conceito de destruição-criativa, do economista Joseph Schumpeter. . O Planejamento e a Gest&#227;o Urbana na Era dos Dados . A comunicação entre o automóvel autônomo e as vias públicas formam um exemplo de mudança que pode ser antevista na cidade, a formação de áreas urbanas em que o fluxo automatizado de informações trazem uma experiência de interatividade digital na própria infraestrutura urbana. Alguns chamam isso de Smart Cities, ou Cidades Inteligentes. Em que pese o conteúdo de marketing nessa conceituação, que não necessariamente implica a efetiva promoção de uma cidade capaz de dar encaminhamento a diversos desafios socio-espaciais urbanos, parece bastante provável que a cidade terá, crescentemente, aportes técnicos que apresentem maior grau de responsividade com as pessoas. . Essa cidade responsiva deve exigir dos planejadores e gestores urbanos uma capacidade de entendimento bastante precisa e ecelarada dos desafios e problemas urbanos. Para tanto, a fim de que a gestão urbana não submerja nessa onda de dados, é importante que os times de gestão estejam preparados para lidar com essa nova etapa, do império dos dados. Nesse sentido, é de se esperar que as equipes multidisciplinares encarregadas da gestão urbana sejam demandadas a apresentar crescente proficiência em trabalhos com dados. Os profissionais da gestão urbana precisam se capacitar para obter, tratar, analisar, modelar e divulgar dados. Em fato, esse fluxo de trabalho não é novidade para qualquer equipe do planejamento e da gestão urbana. O que se coloca, no entanto, é uma premente necessidade de modernização das técnicas e recursos envolvidos em cada uma dessas etapas, de forma a garantir maior eficiência e resultados para a gestão, com melhorias mensuráveis na qualidade de vida nas cidades. . Essa postagem é parte de uma série de textos destinados a basear uma fala proferida a convite do Instituto de Pesquisa e Planejamento Urbano de Curitiba. .",
            "url": "https://augustogeog.github.io/augustogeog/cidade/planejamento%20urbano-regional/palestra%20ippuc/2021/03/31/a-cidade-e-as-ondas-tecnologicas.html",
            "relUrl": "/cidade/planejamento%20urbano-regional/palestra%20ippuc/2021/03/31/a-cidade-e-as-ondas-tecnologicas.html",
            "date": " • Mar 31, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Plotando Gráficos com Python-Altair",
            "content": "O Ecossistema PyData e seus pacotes de plotagem . O ecossistema de Ciência de Dados com Python é conhecido por sua elevada capacidade para auxílio na produção de análises e de modelagem, com base em um conjunto bastante versátil de ferramentas. Nele temos pacotes para computação científica, análise tabular, plotagem de gráficos, análise de dados geográficos, modelagem estatística, machine Learning, Deep Learning e mais. . Quando o assunto é pacotes de plotagem, as opções são diversas e muito interessantes: Matplotlib, Seaborn, Bokeh, Plotly, PlotNine, entre outras. Cada uma delas com suas vantagens e desvantagens. Em meio a esse amplo instrumental, recentemente tenho buscado ter uma noção bastante geral de cada uma das ferramentas, ao mesmo tempo que busco eleger uma ou duas delas para serem aquelas com as quais mais trabalharei nas consultorias, artigos, aulas, projetos e webapps. É aí que entra Altair - leia alter, tal como você chama o peso da academia, não como o nome do seu tio dono do bar. . O que &#233; Altair e por que trabalhar com essa ferramenta de plotagem em Python . Altair é uma ferramenta de plotagem que vem sendo desenvolvida desde 2016 pelo time Altair Developers, que tem participação de desenvolvedores do porte de Brian Granger e Jake VanderPlas, que é um verdadeiro ícone na comunidade PyData. A ferramenta foi utilizada por milhares de analistas e desenvolvedores e é dependência em mais de 8 mil repositórios no GitHub. Trata-se de uma API que gera informações em formato JSON - JavaScript Object Notation -, que armazenam as especificações para que gráficos sejam renderizados no navegador com base em D3.js, um poderoso pacote Javascript para plotagem gráfica, muito conhecido por conta de seus produtos interativos criados por times de ponta, como aquele do New York Times. . Um dos pontos principais de Altair é que o seu time de desenvolvedores busca aplicar a gramática de gráficos, idealizada por Leland Wilkinson, no livro The Grammar of Graphics. Basicamente é uma ideia segundo a qual partimos dos dados e vamos fazendo transformações para a sua representação gráfica. Assim, associamos os dados a um tipo de marcador (barra, círculo, tick, linha etc.), codificamos os tipos de dados (quantativos, ordinais, temporais e nominais) a suas variáveis visuais correspondentes (posições nos eixos x ou y, tamanho dos marcadores, variação de forma dos marcadores, cor etc.), alteramos a escala de expressão desses marcadores (indicamos limites nos eixos, inserimos valores mínimo e máximo para o tamanho dos marcadores, mudamos a paleta de cores etc.) e assim por diante. . Se pensarmos bem, por esse paradigma, fazemos o contrário daquilo que praticamos quando trabalhamos com a API orientada a objeto do Matplotlib, em que declaramos a área do gráfico, inserimos os eixos, nos quais passamos a inserir os demais elementos (marcadores, anotações, rótulos etc.). A intenção, portanto, é que o fluxo de trabalho, com base na gramática de gráficos, auxilie o analista a pensar sobre os dados enquanto está produzindo o gráfico, ao mesmo tempo que conta com uma API de mais fácil utilização do que aquela presente no pacote Matplotlib. . Cabe destacar outro elemento importante do pacote que, por se basear em D3.js, pode gerar gráficos de fácil carregamento em websites e com interatividade, como mudança de escalas, filtros e apresentação de novas informações como resposta a cliques do usuário. Essa interatividade é, na verdade, a grande razão para eu estar estudando o pacote com mais profundidade. Com Altair, os posts deste blog podem ser dinâmicos, sobretudo com a compatibilidade que o pacote tem com FastPages, que é a engine que eu estou usando para que meus Jupyter Notebooks facilmente se tornem postagens. . M&#227;os &#224; Obra! . Mas chega de conversa e mãos à obra! . Instala&#231;&#227;o e Importa&#231;&#227;o do Pacote . Para instalar Altair podemos utilizar Conda ou o instalador de pacotes Python Pip. No terminal podemos utilizar o código abaixo, que também nos permitirá a instalação de alguns conjuntos de dados do pacote Vega. . conda install -c conda-forge altair vega_datasets . Se você não conhece ainda sobre procedimentos para instalação de pacotes, mas quer acompanhar o código adiante, não tem problema. Eu preparei um notebook online para você, na camaradagem. Ainda assim, o assunto é básico e se você não entende de Conda ou Pip, sugiro que volte duas casas e leia a discussão: Qual é a diferença entre pip e conda? . A célula importa o pacote Altair sob o alias - &quot;apelido&quot; - alt, e importa o subpacote data do pacote Vega Datasets . import altair as alt #importanto o pacote altair sob o alias, o &quot;apelido&quot;, alt from vega_datasets import data # importando o subpacote data, do pacote vega_datasets, para termos acesso a bases de dados interessantes para testes de plotagem %config Completer.use_jedi = False #Meu notebook está com problemas para autocompletar o código, e este código corrige o problema . Obten&#231;&#227;o dos Dados: Tidy Data . Vamos começar por carregar alguns dados para podermos analisar com a ajuda das visualizações possibilitadas pelo Altair. O subpacote data apresenta classes que são dataloaders, ou seja, objetos voltados para carregar, como Pandas DataFrame, diferentes tipos de dados disponíveis no pacote Vega Datasets. Entre esses dataloaders, vamos utilizar o gapminder_health_income que apresenta dados de diversos países relativos a condições de saúde e renda. . Ao chamar o objeto gapminder_health_income, podemos atribuir o dataframe à variável de nossa escolha - df_gapminder, no caso adiante. Em seguida, podemos passar a uma brevíssima exploração dos dados, identificando os registros das cinco primeiras linhas, com o método head(). Fica fácil observar que contamos com quatro atributos: country - para os diferentes países -, income - para as diferentes faixas de renda-, health - para diferentes níveis de expectativa de vida - e population, que dispensa apresentações. . Importante observar que os dados se encontram arranjados como tidy data, ou seja, têm formatação ajustada, em que as colunas representam atributos, enquanto as linhas representam diferentes observações. Isso é relevante, pois é essa formatação que é esperada pelo pacote Altair - e também pour outros. . df_gapminder = data.gapminder_health_income() #importação da base de dados de saúde e renda em formato Pandas DataFrame df_gapminder.head() #Observação das cinco primeiras linhas . country income health population . 0 Afghanistan | 1925 | 57.63 | 32526562 | . 1 Albania | 10620 | 76.00 | 2896679 | . 2 Algeria | 13434 | 76.50 | 39666519 | . 3 Andorra | 46577 | 84.10 | 70473 | . 4 Angola | 7615 | 61.00 | 25021974 | . Para termos um pouco mais de noção da estrutura dos dados, vamos utilizar o método info no dataframe Pandas para identificar quantos valores não núlos, além dos tipos de colunas. Vemos que country é do tipo &quot;object&quot;, que é utilizado pelo Pandas para formatos não numéricos, seja string, ou mesmo tipos compostos como listas e dicionários, ao passo que income e população são int64, valores inteiros, e income correspone health corresponde a float64, valores decimais, não havendo valores faltantes na base de dados (os 187 valores estão marcados como non-null). . df_gapminder.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 187 entries, 0 to 186 Data columns (total 4 columns): # Column Non-Null Count Dtype -- -- 0 country 187 non-null object 1 income 187 non-null int64 2 health 187 non-null float64 3 population 187 non-null int64 dtypes: float64(1), int64(2), object(1) memory usage: 6.0+ KB . Plotagem dos dados . Abaixo vamos encontrar o gráfico que queremos produzir e adiante vamos tentar replicá-lo, para observamos alguns aspectos básicos de plotagem com Altair. Ao passarmos o cursor sobre os círculos, uma caixa surge com os dados referentes, que indica a interatividade que queremos obter. De maneira geral, podemos observar que, independente do tamanho populacional, quanto maior a renda de um país, maior a longebidade de seus habitantes. . ´´´Fica aqui a dica para uma das brilhantes palestras de Hans Gosling sobre a relação apresentada no gráfico:´´´ 200 países, 200 anos, 4 minutos. . Para construir esse gráfico, vamos pensar de maneira procedimental, separando cada etapa. Primeiro podemos chamar o objeto Chart, utilizando o dataframe df_gapminder como argumento, seguido pelo método mark_circle(), que indica que as marcas gráficas a serem utilizadas serão círculos. Esse objeto será salvo na variável chart. Note que, ao chamar a variável chart, temos a plotagem de um gráfico bem pequeno. Isso indica que Altair criou para cada linha do dataframe um circulo. Ou seja, temos 189 círculos plotados, mas de uma forma que não nos traz insight, pois faltam outros elementos gráficos para entendermos as relações entre os diferentes atributos, renda, população e expectativa de vida. . chart = alt.Chart(df_gapminder).mark_circle() chart . Como o gráfico acima não nos traz muita informação, é interessante fazermos com que esses círculos, que representam cada amostra, estejam dispostos conforme o eixo horizontal, x, segundo uma dos atributos do dataframe. Isso é o que aa gramática de gráficos preconiza como encoding, ou codificação, a atribuição de uma variável gráfica (disposição no eixo x, no caso) a um tipo de dado, no caso o atributo quantitativo income. . Adiante, basta inserirmos um método encode, com o argumento x igual à coluna de nossa escolha. . chart = alt.Chart(df_gapminder).mark_circle().encode(x= &#39;income&#39;) chart . Exercício semelhante pode ser feito para o eixo vertical, y. . chart = alt.Chart(df_gapminder).mark_circle().encode(y= &#39;health&#39;) chart . Ao juntarmos os dois argumentos, temos uma visão bidimensional, em que a renda se encontra no eixo x e longevidade se encontra no eixo y. Os pares de coordenadas formam a posição de cada marcador, que representa cada uma das amostras, ou países. . chart = alt.Chart(df_gapminder).mark_circle().encode( #declarando o gráfico com círculos e iniciando o método para fazer a codificação x= &#39;income&#39; # codificando o atributo income ao eixo x , y=&#39;health&#39;) # codificando o atributo health ao eixo y chart # chamando o gráfico para que seja renderizado . Esse processo de encoding pode ser feito com diversos tipos de variáveis gráficas (posição x ou y, tamanho, cor, forma etc.). Altair também apresenta codificação para elementos interativos, como tooltip, que corresponde à caixa com informações que surge conforme o usuário passa o cursor sobre um círculo. . chart = alt.Chart(df_gapminder).mark_circle().encode( #declarando o gráfico com círculos e iniciando o método para fazer a codificação x= &#39;income&#39; # codificando o atributo income ao eixo x , y=&#39;health&#39; # codificando o atributo health ao eixo y , size=&#39;population&#39; # codificando o atributo population ao tamanho dos círculos , tooltip=[&#39;country&#39;, &#39;population&#39;, &#39;health&#39;, &#39;income&#39;]) # codificando todos os atributos ao tooltip chart # chamando o gráfico para que seja renderizado . É possível fazer uma grande encadeamento de métodos que criam alterações no gráfico. No entanto, para que isso não se torne confuso, podemos salvar cada etapa na variável chart, o que pode fazer o código se tornar visualmente mais simples, o que permite manutenção mais fácil. Uma coisa que podemos notar é que Altair pode receber, como argumentos de codificação, valores bastante simples, como as strings que apontam para o nome das colunas. No entanto, para que possamos ter mais poder de customização, altair conta com alguns objetos chamados de schema wrappers, que permitem maior nível de detalhe nas opções que serão passadas para VegaLite e para renderização. No argumento x, podemos inserir, portanto, o objeto wrappers alt.X, que terá diversos argumentos, que correspondem a opções, como, por exemplo uso de escala logarítmica, possibilidade não iniciar as marcações a partir do zero e título do eixo. Abaixo os argumentos x, y e size receberam wrapers com diversas especificações. . chart = alt.Chart(df_gapminder).mark_circle() chart = chart.encode( x= alt.X(&#39;income:Q&#39;, scale=alt.Scale(type=&#39;log&#39;, zero=False, domain=[500, 120000]), title=&#39;Renda&#39;) , y=alt.Y(&#39;health:Q&#39;, scale=alt.Scale(zero=False), title=&#39;Expectativa de Vida&#39;) , size=alt.Size(&#39;population:Q&#39;, scale=alt.Scale(zero=False,range=[5, 2000]), legend=alt.Legend(labelFontSize=10), title=&#39;População&#39;) , tooltip=[&#39;country&#39;, &#39;population&#39;, &#39;health&#39;, &#39;income&#39;] ) chart . Adiante podemos avançar para alterar algumas propriedades, alterando a largura do gráfico (width), . chart = alt.Chart(df_gapminder).mark_circle() chart = chart.encode( x= alt.X(&#39;income&#39;, scale=alt.Scale(type=&#39;log&#39;, zero=False, domain=[500, 120000]), title=&#39;Renda&#39;) , y=alt.Y(&#39;health&#39;, scale=alt.Scale(zero=False), title=&#39;Expectativa de Vida&#39;) , size=alt.Size(&#39;population:Q&#39;, scale=alt.Scale(zero=False,range=[5, 2000]), legend=alt.Legend(labelFontSize=10), title=&#39;População&#39;) , tooltip=[&#39;country&#39;, &#39;population&#39;, &#39;health&#39;, &#39;income&#39;] ) chart = chart.properties( width=890, # alteração da largural title=&#39;Relação entre Expectativa de Vida e Renda em Diferentes Países&#39; #inserção de título do gráfico ) chart = chart.configure_title(fontSize=20) #mudança do tamanho da fonte do título chart . O gráfico já está muito melhor, servindo como protótipo de produto. Para produto final, diversas questões ainda precisariam de encaminhamento, como ajuste dos limites do eixo X, inserção de valores círculos menores na legenda da População. Ainda assim, já foi o suficiente para conhecermos Altair e alguns de seus recursos básicos. .",
            "url": "https://augustogeog.github.io/augustogeog/altair/gr%C3%A1ficos/2021/03/05/graficos-altair.html",
            "relUrl": "/altair/gr%C3%A1ficos/2021/03/05/graficos-altair.html",
            "date": " • Mar 5, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://augustogeog.github.io/augustogeog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am a Geographer, witha PhD in Urban and Regional Planning. I work with Python and its wonderful Data Science ecosystem to analyze data related to Urban and Regional Planning, Geography and Social Sciences in General. .",
          "url": "https://augustogeog.github.io/augustogeog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://augustogeog.github.io/augustogeog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}