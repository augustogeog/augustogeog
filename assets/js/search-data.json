{
  
    
        "post0": {
            "title": "Plotando Gráficos com Python-Altair",
            "content": "O Ecossistema PyData e seus pacotes de plotagem . O ecossistema de Ciência de Dados com Python é conhecido por sua elevada capacidade para auxílio na produção de análises e de modelagem, com base em um conjunto bastante versátil de ferramentas. Nele temos pacotes para computação científica, análise tabular, plotagem de gráficos, análise de dados geográficos, modelagem estatística, machine Learning, Deep Learning e mais. . Quando o assunto é pacotes de plotagem, as opções são diversas e muito interessantes: Matplotlib, Seaborn, Bokeh, Plotly, PlotNine, entre outras. Cada uma delas com suas vantagens e desvantagens. Em meio a esse amplo instrumental, recentemente tenho buscado ter uma noção bastante geral de cada uma das ferramentas, ao mesmo tempo que busco eleger uma ou duas delas para serem aquelas com as quais mais trabalharei nas consultorias, artigos, aulas, projetos e webapps. É aí que entra Altair - leia alter, tal como você chama o peso da academia, não como o nome do seu tio dono do bar. . O que &#233; Altair e por que trabalhar com essa ferramenta de plotagem em Python . Altair é uma ferramenta de plotagem que vem sendo desenvolvida desde 2016 pelo time Altair Developers, que tem participação de desenvolvedores do porte de Brian Granger e Jake VanderPlas, que é um verdadeiro ícone na comunidade PyData. A ferramenta foi utilizada por milhares de analistas e desenvolvedores e é dependência em mais de 8 mil repositórios no GitHub. Trata-se de uma API que gera informações em formato JSON - JavaScript Object Notation -, que armazenam as especificações para que gráficos sejam renderizados no navegador com base em D3.js, um poderoso pacote Javascript para plotagem gráfica, muito conhecido por conta de seus produtos interativos criados por times de ponta, como aquele do New York Times. . Um dos pontos principais de Altair é que o seu time de desenvolvedores busca aplicar a gramática de gráficos, idealizada por Leland Wilkinson, no livro The Grammar of Graphics. Basicamente é uma ideia segundo a qual partimos dos dados e vamos fazendo transformações para a sua representação gráfica. Assim, associamos os dados a um tipo de marcador (barra, círculo, tick, linha etc.), codificamos os tipos de dados (quantativos, ordinais, temporais e nominais) a suas variáveis visuais correspondentes (posições nos eixos x ou y, tamanho dos marcadores, variação de forma dos marcadores, cor etc.), alteramos a escala de expressão desses marcadores (indicamos limites nos eixos, inserimos valores mínimo e máximo para o tamanho dos marcadores, mudamos a paleta de cores etc.) e assim por diante. . Se pensarmos bem, por esse paradigma, fazemos o contrário daquilo que praticamos quando trabalhamos com a API orientada a objeto do Matplotlib, em que declaramos a área do gráfico, inserimos os eixos, nos quais passamos a inserir os demais elementos (marcadores, anotações, rótulos etc.). A intenção, portanto, é que o fluxo de trabalho, com base na gramática de gráficos, auxilie o analista a pensar sobre os dados enquanto está produzindo o gráfico, ao mesmo tempo que conta com uma API de mais fácil utilização do que aquela presente no pacote Matplotlib. . Cabe destacar outro elemento importante do pacote que, por se basear em D3.js, pode gerar gráficos de fácil carregamento em websites e com interatividade, como mudança de escalas, filtros e apresentação de novas informações como resposta a cliques do usuário. Essa interatividade é, na verdade, a grande razão para eu estar estudando o pacote com mais profundidade. Com Altair, os posts deste blog podem ser dinâmicos, sobretudo com a compatibilidade que o pacote tem com FastPages, que é a engine que eu estou usando para que meus Jupyter Notebooks facilmente se tornem postagens. . M&#227;os &#224; Obra! . Mas chega de conversa e mãos à obra! . Instala&#231;&#227;o e Importa&#231;&#227;o do Pacote . Para instalar Altair podemos utilizar Conda ou o instalador de pacotes Python Pip. No terminal podemos utilizar o código abaixo, que também nos permitirá a instalação de alguns conjuntos de dados do pacote Vega. . conda install -c conda-forge altair vega_datasets . Se você não conhece ainda sobre procedimentos para instalação de pacotes, mas quer acompanhar o código adiante, não tem problema. Eu preparei um notebook online para você, na camaradagem. Ainda assim, o assunto é básico e se você não entende de Conda ou Pip, sugiro que volte duas casas e leia a discussão: Qual é a diferença entre pip e conda? . A célula importa o pacote Altair sob o alias - &quot;apelido&quot; - alt, e importa o subpacote data do pacote Vega Datasets . import altair as alt #importanto o pacote altair sob o alias, o &quot;apelido&quot;, alt from vega_datasets import data # importando o subpacote data, do pacote vega_datasets, para termos acesso a bases de dados interessantes para testes de plotagem %config Completer.use_jedi = False #Meu notebook está com problemas para autocompletar o código, e este código corrige o problema . Obten&#231;&#227;o dos Dados: Tidy Data . Vamos começar por carregar alguns dados para podermos analisar com a ajuda das visualizações possibilitadas pelo Altair. O subpacote data apresenta classes que são dataloaders, ou seja, objetos voltados para carregar, como Pandas DataFrame, diferentes tipos de dados disponíveis no pacote Vega Datasets. Entre esses dataloaders, vamos utilizar o gapminder_health_income que apresenta dados de diversos países relativos a condições de saúde e renda. . Ao chamar o objeto gapminder_health_income, podemos atribuir o dataframe à variável de nossa escolha - df_gapminder, no caso adiante. Em seguida, podemos passar a uma brevíssima exploração dos dados, identificando os registros das cinco primeiras linhas, com o método head(). Fica fácil observar que contamos com quatro atributos: country - para os diferentes países -, income - para as diferentes faixas de renda-, health - para diferentes níveis de expectativa de vida - e population, que dispensa apresentações. . Importante observar que os dados se encontram arranjados como tidy data, ou seja, têm formatação ajustada, em que as colunas representam atributos, enquanto as linhas representam diferentes observações. Isso é relevante, pois é essa formatação que é esperada pelo pacote Altair - e também pour outros. . df_gapminder = data.gapminder_health_income() #importação da base de dados de saúde e renda em formato Pandas DataFrame df_gapminder.head() #Observação das cinco primeiras linhas . country income health population . 0 Afghanistan | 1925 | 57.63 | 32526562 | . 1 Albania | 10620 | 76.00 | 2896679 | . 2 Algeria | 13434 | 76.50 | 39666519 | . 3 Andorra | 46577 | 84.10 | 70473 | . 4 Angola | 7615 | 61.00 | 25021974 | . Para termos um pouco mais de noção da estrutura dos dados, vamos utilizar o método info no dataframe Pandas para identificar quantos valores não núlos, além dos tipos de colunas. Vemos que country é do tipo &quot;object&quot;, que é utilizado pelo Pandas para formatos não numéricos, seja string, ou mesmo tipos compostos como listas e dicionários, ao passo que income e população são int64, valores inteiros, e income correspone health corresponde a float64, valores decimais, não havendo valores faltantes na base de dados (os 187 valores estão marcados como non-null). . df_gapminder.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 187 entries, 0 to 186 Data columns (total 4 columns): # Column Non-Null Count Dtype -- -- 0 country 187 non-null object 1 income 187 non-null int64 2 health 187 non-null float64 3 population 187 non-null int64 dtypes: float64(1), int64(2), object(1) memory usage: 6.0+ KB . Plotagem dos dados . Abaixo vamos encontrar o gráfico que queremos produzir e adiante vamos tentar replicá-lo, para observamos alguns aspectos básicos de plotagem com Altair. Ao passarmos o cursor sobre os círculos, uma caixa surge com os dados referentes, que indica a interatividade que queremos obter. De maneira geral, podemos observar que, independente do tamanho populacional, quanto maior a renda de um país, maior a longebidade de seus habitantes. . ´´´Fica aqui a dica para uma das brilhantes palestras de Hans Gosling sobre a relação apresentada no gráfico:´´´ 200 países, 200 anos, 4 minutos. . Para construir esse gráfico, vamos pensar de maneira procedimental, separando cada etapa. Primeiro podemos chamar o objeto Chart, utilizando o dataframe df_gapminder como argumento, seguido pelo método mark_circle(), que indica que as marcas gráficas a serem utilizadas serão círculos. Esse objeto será salvo na variável chart. Note que, ao chamar a variável chart, temos a plotagem de um gráfico bem pequeno. Isso indica que Altair criou para cada linha do dataframe um circulo. Ou seja, temos 189 círculos plotados, mas de uma forma que não nos traz insight, pois faltam outros elementos gráficos para entendermos as relações entre os diferentes atributos, renda, população e expectativa de vida. . chart = alt.Chart(df_gapminder).mark_circle() chart . Como o gráfico acima não nos traz muita informação, é interessante fazermos com que esses círculos, que representam cada amostra, estejam dispostos conforme o eixo horizontal, x, segundo uma dos atributos do dataframe. Isso é o que aa gramática de gráficos preconiza como encoding, ou codificação, a atribuição de uma variável gráfica (disposição no eixo x, no caso) a um tipo de dado, no caso o atributo quantitativo income. . Adiante, basta inserirmos um método encode, com o argumento x igual à coluna de nossa escolha. . chart = alt.Chart(df_gapminder).mark_circle().encode(x= &#39;income&#39;) chart . Exercício semelhante pode ser feito para o eixo vertical, y. . chart = alt.Chart(df_gapminder).mark_circle().encode(y= &#39;health&#39;) chart . Ao juntarmos os dois argumentos, temos uma visão bidimensional, em que a renda se encontra no eixo x e longevidade se encontra no eixo y. Os pares de coordenadas formam a posição de cada marcador, que representa cada uma das amostras, ou países. . chart = alt.Chart(df_gapminder).mark_circle().encode( #declarando o gráfico com círculos e iniciando o método para fazer a codificação x= &#39;income&#39; # codificando o atributo income ao eixo x , y=&#39;health&#39;) # codificando o atributo health ao eixo y chart # chamando o gráfico para que seja renderizado . Esse processo de encoding pode ser feito com diversos tipos de variáveis gráficas (posição x ou y, tamanho, cor, forma etc.). Altair também apresenta codificação para elementos interativos, como tooltip, que corresponde à caixa com informações que surge conforme o usuário passa o cursor sobre um círculo. . chart = alt.Chart(df_gapminder).mark_circle().encode( #declarando o gráfico com círculos e iniciando o método para fazer a codificação x= &#39;income&#39; # codificando o atributo income ao eixo x , y=&#39;health&#39; # codificando o atributo health ao eixo y , size=&#39;population&#39; # codificando o atributo population ao tamanho dos círculos , tooltip=[&#39;country&#39;, &#39;population&#39;, &#39;health&#39;, &#39;income&#39;]) # codificando todos os atributos ao tooltip chart # chamando o gráfico para que seja renderizado . É possível fazer uma grande encadeamento de métodos que criam alterações no gráfico. No entanto, para que isso não se torne confuso, podemos salvar cada etapa na variável chart, o que pode fazer o código se tornar visualmente mais simples, o que permite manutenção mais fácil. Uma coisa que podemos notar é que Altair pode receber, como argumentos de codificação, valores bastante simples, como as strings que apontam para o nome das colunas. No entanto, para que possamos ter mais poder de customização, altair conta com alguns objetos chamados de schema wrappers, que permitem maior nível de detalhe nas opções que serão passadas para VegaLite e para renderização. No argumento x, podemos inserir, portanto, o objeto wrappers alt.X, que terá diversos argumentos, que correspondem a opções, como, por exemplo uso de escala logarítmica, possibilidade não iniciar as marcações a partir do zero e título do eixo. Abaixo os argumentos x, y e size receberam wrapers com diversas especificações. . chart = alt.Chart(df_gapminder).mark_circle() chart = chart.encode( x= alt.X(&#39;income:Q&#39;, scale=alt.Scale(type=&#39;log&#39;, zero=False, domain=[500, 120000]), title=&#39;Renda&#39;) , y=alt.Y(&#39;health:Q&#39;, scale=alt.Scale(zero=False), title=&#39;Expectativa de Vida&#39;) , size=alt.Size(&#39;population:Q&#39;, scale=alt.Scale(zero=False,range=[5, 2000]), legend=alt.Legend(labelFontSize=10), title=&#39;População&#39;) , tooltip=[&#39;country&#39;, &#39;population&#39;, &#39;health&#39;, &#39;income&#39;] ) chart . Adiante podemos avançar para alterar algumas propriedades, alterando a largura do gráfico (width), . chart = alt.Chart(df_gapminder).mark_circle() chart = chart.encode( x= alt.X(&#39;income&#39;, scale=alt.Scale(type=&#39;log&#39;, zero=False, domain=[500, 120000]), title=&#39;Renda&#39;) , y=alt.Y(&#39;health&#39;, scale=alt.Scale(zero=False), title=&#39;Expectativa de Vida&#39;) , size=alt.Size(&#39;population:Q&#39;, scale=alt.Scale(zero=False,range=[5, 2000]), legend=alt.Legend(labelFontSize=10), title=&#39;População&#39;) , tooltip=[&#39;country&#39;, &#39;population&#39;, &#39;health&#39;, &#39;income&#39;] ) chart = chart.properties( width=890, # alteração da largural title=&#39;Relação entre Expectativa de Vida e Renda em Diferentes Países&#39; #inserção de título do gráfico ) chart = chart.configure_title(fontSize=20) #mudança do tamanho da fonte do título chart . O gráfico já está muito melhor, servindo como protótipo de produto. Para produto final, diversas questões ainda precisariam de encaminhamento, como ajuste dos limites do eixo X, inserção de valores círculos menores na legenda da População. Ainda assim, já foi o suficiente para conhecermos Altair e alguns de seus recursos básicos. .",
            "url": "https://augustogeog.github.io/augustogeog/altair/gr%C3%A1ficos/2021/03/05/graficos-altair.html",
            "relUrl": "/altair/gr%C3%A1ficos/2021/03/05/graficos-altair.html",
            "date": " • Mar 5, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://augustogeog.github.io/augustogeog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am a Geographer, witha PhD in Urban and Regional Planning. I work with Python and its wonderful Data Science ecosystem to analyze data related to Urban and Regional Planning, Geography and Social Sciences in General. .",
          "url": "https://augustogeog.github.io/augustogeog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://augustogeog.github.io/augustogeog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}